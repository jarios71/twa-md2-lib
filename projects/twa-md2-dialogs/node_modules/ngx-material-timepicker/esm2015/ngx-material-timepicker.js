import * as _moment from 'moment';
import { utc } from 'moment';
import { Injectable, Component, EventEmitter, HostListener, Input, Output, Pipe, ElementRef, ViewChild, Directive, forwardRef, Inject, Optional, ContentChild, NgModule } from '@angular/core';
import { BehaviorSubject, Subject, merge } from 'rxjs';
import { animate, style, transition, trigger } from '@angular/animations';
import { filter } from 'rxjs/operators';
import { DomSanitizer } from '@angular/platform-browser';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { DOCUMENT, CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const TimePeriod = {
    AM: 'AM',
    PM: 'PM',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const TimeFormat = {
    TWELVE: 'hh:mm a',
    TWENTY_FOUR: 'HH:mm',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const moment = _moment;
class TimeAdapter {
    /**
     * @param {?} time
     * @param {?=} format
     * @return {?}
     */
    static formatTime(time, format = 12) {
        const /** @type {?} */ timeFormat = format === 24 ? TimeFormat.TWENTY_FOUR : TimeFormat.TWELVE;
        return moment(time, timeFormat).format(timeFormat);
    }
    /**
     * @param {?} time
     * @return {?}
     */
    static convertTimeToMoment(time) {
        return moment(time, TimeFormat.TWELVE);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const moment$1 = _moment;
const DEFAULT_HOUR = {
    time: 12,
    angle: 360
};
const DEFAULT_MINUTE = {
    time: '00',
    angle: 360
};
class NgxMaterialTimepickerService {
    constructor() {
        this.hourSubject = new BehaviorSubject(DEFAULT_HOUR);
        this.minuteSubject = new BehaviorSubject(DEFAULT_MINUTE);
        this.periodSubject = new BehaviorSubject(TimePeriod.AM);
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    set hour(hour) {
        this.hourSubject.next(hour);
    }
    /**
     * @return {?}
     */
    get selectedHour() {
        return this.hourSubject.asObservable();
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    set minute(minute) {
        this.minuteSubject.next(minute);
    }
    /**
     * @return {?}
     */
    get selectedMinute() {
        return this.minuteSubject.asObservable();
    }
    /**
     * @param {?} period
     * @return {?}
     */
    set period(period) {
        this.periodSubject.next(period);
    }
    /**
     * @return {?}
     */
    get selectedPeriod() {
        return this.periodSubject.asObservable();
    }
    /**
     * @param {?} time
     * @return {?}
     */
    set defaultTime(time) {
        const /** @type {?} */ defaultTime = moment$1(time, TimeFormat.TWENTY_FOUR).toDate();
        if (moment$1(defaultTime).isValid()) {
            this.hour = Object.assign({}, DEFAULT_HOUR, { time: defaultTime.getHours() === 0 ? '00' : defaultTime.getHours() });
            this.minute = Object.assign({}, DEFAULT_MINUTE, { time: defaultTime.getMinutes() === 0 ? '00' : defaultTime.getMinutes() });
            this.period = /** @type {?} */ (time.substr(time.length - 2).toUpperCase());
        }
        else {
            this.resetTime();
        }
    }
    /**
     * @param {?} format
     * @return {?}
     */
    getFullTime(format) {
        const /** @type {?} */ hour = this.hourSubject.getValue().time;
        const /** @type {?} */ minute = this.minuteSubject.getValue().time;
        const /** @type {?} */ period = this.periodSubject.getValue();
        return TimeAdapter.formatTime(`${hour}:${minute} ${period}`, format);
    }
    /**
     * @return {?}
     */
    resetTime() {
        this.hour = Object.assign({}, DEFAULT_HOUR);
        this.minute = Object.assign({}, DEFAULT_MINUTE);
        this.period = TimePeriod.AM;
    }
}
NgxMaterialTimepickerService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgxMaterialTimepickerService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const TimeUnit = {
    HOUR: 0,
    MINUTE: 1,
};
TimeUnit[TimeUnit.HOUR] = "HOUR";
TimeUnit[TimeUnit.MINUTE] = "MINUTE";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMaterialTimepickerEventService {
    constructor() {
        this.backdropClickSubject = new Subject();
        this.keydownEventSubject = new Subject();
    }
    /**
     * @return {?}
     */
    get backdropClick() {
        return this.backdropClickSubject.asObservable();
    }
    /**
     * @return {?}
     */
    get keydownEvent() {
        return this.keydownEventSubject.asObservable();
    }
}
NgxMaterialTimepickerEventService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgxMaterialTimepickerEventService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const AnimationState = {
    ENTER: 'enter',
    LEAVE: 'leave',
};
const ESCAPE = 27;
class NgxMaterialTimepickerComponent {
    /**
     * @param {?} timepickerService
     * @param {?} eventService
     */
    constructor(timepickerService, eventService) {
        this.timepickerService = timepickerService;
        this.eventService = eventService;
        this.timePeriod = TimePeriod;
        this.timeUnit = TimeUnit;
        this.activeTimeUnit = TimeUnit.HOUR;
        this.isOpened = false;
        this.subscriptions = [];
        this.isEsc = true;
        this.timeSet = new EventEmitter();
        this.closed = new EventEmitter();
        this.subscriptions.push(merge(this.eventService.backdropClick, this.eventService.keydownEvent.pipe(filter(e => e.keyCode === ESCAPE && this.isEsc)))
            .subscribe(() => this.close()));
    }
    /**
     * @return {?}
     */
    get minTime() {
        return this.timepickerInput && this.timepickerInput.min;
    }
    /**
     * @return {?}
     */
    get maxTime() {
        return this.timepickerInput && this.timepickerInput.max;
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this.timepickerInput && this.timepickerInput.disabled;
    }
    /**
     * @return {?}
     */
    get format() {
        return this.timepickerInput && this.timepickerInput.format;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.timepickerService.selectedHour
            .subscribe(hour => this.selectedHour = hour));
        this.subscriptions.push(this.timepickerService.selectedMinute
            .subscribe(minute => this.selectedMinute = minute));
        this.subscriptions.push(this.timepickerService.selectedPeriod
            .subscribe(period => this.selectedPeriod = period));
    }
    /**
     *
     * Register an input with this timepicker.
     * input - The timepicker input to register with this timepicker
     * @param {?} input
     * @return {?}
     */
    registerInput(input) {
        if (this.timepickerInput) {
            throw Error('A Timepicker can only be associated with a single input.');
        }
        this.timepickerInput = input;
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    onHourChange(hour) {
        this.timepickerService.hour = hour;
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    onMinuteChange(minute) {
        this.timepickerService.minute = minute;
    }
    /**
     * @param {?} period
     * @return {?}
     */
    changePeriod(period) {
        this.timepickerService.period = period;
    }
    /**
     * @param {?} unit
     * @return {?}
     */
    changeTimeUnit(unit) {
        this.activeTimeUnit = unit;
    }
    /**
     * @return {?}
     */
    setTime() {
        this.timeSet.next(this.timepickerService.getFullTime(this.format));
        this.close();
    }
    /**
     * @param {?} time
     * @return {?}
     */
    setDefaultTime(time) {
        this.timepickerService.defaultTime = time;
    }
    /**
     * @return {?}
     */
    open() {
        this.isOpened = true;
        this.animationState = AnimationState.ENTER;
    }
    /**
     * @return {?}
     */
    close() {
        this.animationState = AnimationState.LEAVE;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    animationDone(event) {
        if (event.phaseName === 'done' && event.toState === AnimationState.LEAVE) {
            this.isOpened = false;
            this.activeTimeUnit = TimeUnit.HOUR;
            this.closed.next();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeydown(e) {
        this.eventService.keydownEventSubject.next(e);
        e.stopPropagation();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
    }
}
NgxMaterialTimepickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker',
                template: `<div class="timepicker-backdrop-overlay" *ngIf="isOpened" overlay></div>
<div class="timepicker-overlay" *ngIf="isOpened">
    <div class="timepicker" [@timepicker]="animationState" (@timepicker.done)="animationDone($event)" tabindex="0"
         focusAnchor>
        <header class="timepicker__header">
            <div class="timepicker-dial">
                <div class="timepicker-dial__time">
				<span class="timepicker-dial__item"
                      [ngClass]="{'timepicker-dial__item_active': activeTimeUnit === timeUnit.HOUR}"
                      (click)="changeTimeUnit(timeUnit.HOUR)">
					{{selectedHour?.time | timeFormatter: timeUnit.HOUR}}</span>:<span
                    class="timepicker-dial__item"
                    [ngClass]="{'timepicker-dial__item_active': activeTimeUnit === timeUnit.MINUTE}"
                    (click)="changeTimeUnit(timeUnit.MINUTE)">{{selectedMinute?.time | timeFormatter: timeUnit.MINUTE}}</span>
                </div>
                <div class="timepicker-dial__period" *ngIf="format !== 24">
			<span class="timepicker-dial__item"
                  [ngClass]="{'timepicker-dial__item_active': selectedPeriod === timePeriod.AM}"
                  (click)="changePeriod(timePeriod.AM)">AM</span>
                    <span class="timepicker-dial__item"
                          [ngClass]="{'timepicker-dial__item_active': selectedPeriod === timePeriod.PM}"
                          (click)="changePeriod(timePeriod.PM)">PM</span>
                </div>
            </div>
        </header>
        <div class="timepicker__main-content">
            <div class="timepicker__body" [ngSwitch]="activeTimeUnit">
                <div *ngSwitchCase="timeUnit.HOUR">
                    <ngx-material-timepicker-24-hours-face *ngIf="format === 24;else ampmHours"
                                                           (hourChange)="onHourChange($event)"
                                                           [selectedHour]="selectedHour"
                                                           [minTime]="minTime"
                                                           [maxTime]="maxTime"
                                                           [format]="format"
                                                           (hourSelected)="activeTimeUnit = timeUnit.MINUTE"></ngx-material-timepicker-24-hours-face>
                    <ng-template #ampmHours>
                        <ngx-material-timepicker-12-hours-face
                            (hourChange)="onHourChange($event)"
                            [selectedHour]="selectedHour"
                            [period]="selectedPeriod"
                            [minTime]="minTime"
                            [maxTime]="maxTime"
                            (hourSelected)="activeTimeUnit = timeUnit.MINUTE"></ngx-material-timepicker-12-hours-face>
                    </ng-template>
                </div>
                <ngx-material-timepicker-minutes-face *ngSwitchCase="timeUnit.MINUTE"
                                                      [selectedMinute]="selectedMinute"
                                                      [selectedHour]="selectedHour?.time"
                                                      [minTime]="minTime"
                                                      [maxTime]="maxTime"
                                                      [period]="selectedPeriod"
                                                      (minuteChange)="onMinuteChange($event)"></ngx-material-timepicker-minutes-face>
            </div>
            <div class="timepicker__actions">
                <div (click)="close()">
                    <ng-container *ngTemplateOutlet="cancelBtnTmpl ? cancelBtnTmpl : cancelBtnDefault"></ng-container>
                </div>
                <div (click)="setTime()">
                    <ng-container
                        *ngTemplateOutlet="confirmBtnTmpl ? confirmBtnTmpl : confirmBtnDefault"></ng-container>
                </div>
            </div>
        </div>
    </div>
</div>
<ng-template #cancelBtnDefault>
    <ngx-material-timepicker-button>Cancel</ngx-material-timepicker-button>
</ng-template>
<ng-template #confirmBtnDefault>
    <ngx-material-timepicker-button>Ok</ngx-material-timepicker-button>
</ng-template>
`,
                styles: [`@import url(https://fonts.googleapis.com/css?family=Roboto:400,500,700);.timepicker-backdrop-overlay{position:fixed;top:0;bottom:0;right:0;left:0;background-color:rgba(0,0,0,.3);z-index:999;pointer-events:auto}.timepicker-overlay{position:fixed;top:0;left:0;width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;z-index:999;pointer-events:none}.timepicker{width:300px;border-radius:2px;-webkit-box-shadow:rgba(0,0,0,.25) 0 14px 45px,rgba(0,0,0,.22) 0 10px 18px;box-shadow:rgba(0,0,0,.25) 0 14px 45px,rgba(0,0,0,.22) 0 10px 18px;outline:0;position:static;z-index:999;pointer-events:auto}.timepicker__header{background-color:#00bfff;padding:15px 30px}.timepicker__body{background-color:#fff;padding:15px 5px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.timepicker__actions{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;padding:15px;background-color:#fff}.timepicker-dial{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;-webkit-tap-highlight-color:transparent}.timepicker-dial__time{line-height:normal;font-size:50px;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.timepicker-dial__period{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin-left:10px;font-size:18px;font-weight:500;font-family:Roboto,sans-serif;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.timepicker-dial__item{cursor:pointer;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}.timepicker-dial__item_active{color:#fff}@media (max-width:1023px) and (orientation:landscape){.timepicker{display:-webkit-box;display:-ms-flexbox;display:flex;width:515px}.timepicker__header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.timepicker__main-content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;width:100%}.timepicker__actions{padding:5px;margin-top:-1px}.timepicker-dial{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.timepicker-dial__period{margin-left:0}}`],
                animations: [
                    trigger('timepicker', [
                        transition(`* => ${AnimationState.ENTER}`, [
                            style({ transform: 'translateY(-30%)' }),
                            animate('0.2s ease-out', style({ transform: 'translateY(0)' }))
                        ]),
                        transition(`${AnimationState.ENTER} => ${AnimationState.LEAVE}`, [
                            style({ transform: 'translateY(0)', opacity: 1 }),
                            animate('0.2s ease-out', style({ transform: 'translateY(-30%)', opacity: 0 }))
                        ])
                    ])
                ],
                providers: [NgxMaterialTimepickerService]
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerComponent.ctorParameters = () => [
    { type: NgxMaterialTimepickerService, },
    { type: NgxMaterialTimepickerEventService, },
];
NgxMaterialTimepickerComponent.propDecorators = {
    "cancelBtnTmpl": [{ type: Input },],
    "confirmBtnTmpl": [{ type: Input },],
    "isEsc": [{ type: Input, args: ['ESC',] },],
    "timeSet": [{ type: Output },],
    "closed": [{ type: Output },],
    "onKeydown": [{ type: HostListener, args: ['keydown', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class StyleSanitizerPipe {
    /**
     * @param {?} domSanitizer
     */
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        if (!value) {
            return value;
        }
        return this.domSanitizer.bypassSecurityTrustStyle(value);
    }
}
StyleSanitizerPipe.decorators = [
    { type: Pipe, args: [{
                name: 'styleSanitizer'
            },] },
];
/** @nocollapse */
StyleSanitizerPipe.ctorParameters = () => [
    { type: DomSanitizer, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const moment$2 = _moment;
const MINUTES = 60;
class NgxMaterialTimepickerMinutesFaceComponent {
    constructor() {
        this.minutesList = [];
        this.timeUnit = TimeUnit;
        this.minuteChange = new EventEmitter();
        const /** @type {?} */ angleStep = 360 / MINUTES;
        this.minutesList = Array(MINUTES).fill(0).map((v, i) => {
            const /** @type {?} */ index = (v + i);
            const /** @type {?} */ angle = angleStep * index;
            return { time: index === 0 ? '00' : index, angle: angle !== 0 ? angle : 360 };
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedHour(value) {
        this._selectedHour = value === 12 ? 0 : value;
    }
    /**
     * @return {?}
     */
    get disabledMinutes() {
        if (this.minTime || this.maxTime) {
            return this.minutesList.map(value => {
                const /** @type {?} */ hour = this.period === TimePeriod.AM ? this._selectedHour : this._selectedHour + 12;
                const /** @type {?} */ currentTime = moment$2().hour(hour).minute(+value.time);
                return Object.assign({}, value, { disabled: currentTime.isBefore(this.minTime || null, 'minutes')
                        || currentTime.isAfter(this.maxTime || null, 'minutes') });
            });
        }
        return this.minutesList;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['period'] && changes['period'].currentValue) {
            this.minutesList = this.disabledMinutes;
        }
    }
}
NgxMaterialTimepickerMinutesFaceComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-minutes-face',
                template: `<ngx-material-timepicker-face [faceTime]="minutesList" [selectedTime]="selectedMinute"
                              (timeChange)="minuteChange.next($event)" [unit]="timeUnit.MINUTE"></ngx-material-timepicker-face>
`
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerMinutesFaceComponent.ctorParameters = () => [];
NgxMaterialTimepickerMinutesFaceComponent.propDecorators = {
    "selectedMinute": [{ type: Input },],
    "period": [{ type: Input },],
    "minTime": [{ type: Input },],
    "maxTime": [{ type: Input },],
    "selectedHour": [{ type: Input },],
    "minuteChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const CLOCK_HAND_STYLES = {
    small: {
        height: '75px',
        top: 'calc(50% - 75px)'
    },
    large: {
        height: '103px',
        top: 'calc(50% - 103px)'
    }
};
class NgxMaterialTimepickerFaceComponent {
    constructor() {
        this.timeUnit = TimeUnit;
        this.innerClockFaceSize = 85;
        this.timeChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.setClockHandPosition();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ((changes['faceTime'] && changes['faceTime'].currentValue)
            && (changes['selectedTime'] && changes['selectedTime'].currentValue)) {
            //Set time according to passed an input value
            this.selectedTime = this.faceTime.find(time => time.time === this.selectedTime.time);
        }
        if (changes['selectedTime'] && changes['selectedTime'].currentValue) {
            this.setClockHandPosition();
        }
        if (changes['faceTime'] && changes['faceTime'].currentValue) {
            // To avoid an error ExpressionChangedAfterItHasBeenCheckedError
            setTimeout(() => this.selectAvailableTime());
        }
    }
    /**
     * @param {?} _
     * @param {?} time
     * @return {?}
     */
    trackByTime(_, time) {
        return time.time;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMousedown(e) {
        e.preventDefault();
        this.isStarted = true;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    selectTime(e) {
        if (!this.isStarted && (e instanceof MouseEvent && e.type !== 'click')) {
            return;
        }
        const /** @type {?} */ clockFaceCords = this.clockFace.nativeElement.getBoundingClientRect();
        //Get x0 and y0 of the circle
        const /** @type {?} */ centerX = clockFaceCords.left + clockFaceCords.width / 2;
        const /** @type {?} */ centerY = clockFaceCords.top + clockFaceCords.height / 2;
        //Counting the arctangent and convert it to from radian to deg
        const /** @type {?} */ arctangent = Math.atan(Math.abs(e.clientX - centerX) / Math.abs(e.clientY - centerY)) * 180 / Math.PI;
        //Get angle according to quadrant
        const /** @type {?} */ circleAngle = countAngleByCords(centerX, centerY, e.clientX, e.clientY, arctangent);
        //Check if selected time from the inner clock face (24 hours format only)
        const /** @type {?} */ isInnerClockChosen = this.format && this.isInnerClockFace(centerX, centerY, e.clientX, e.clientY);
        //Round angle according to angle step
        const /** @type {?} */ angleStep = this.unit === TimeUnit.MINUTE ? 6 : 30;
        const /** @type {?} */ roundedAngle = isInnerClockChosen
            ? roundAngle(circleAngle, angleStep) + 360
            : roundAngle(circleAngle, angleStep);
        const /** @type {?} */ selectedTime = this.faceTime.find(val => val.angle === roundedAngle);
        if (!selectedTime.disabled) {
            this.timeChange.next(selectedTime);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseup(e) {
        e.preventDefault();
        this.isStarted = false;
    }
    /**
     * @return {?}
     */
    setClockHandPosition() {
        if (this.format === 24) {
            if (this.selectedTime.time > 12 || this.selectedTime.time === '00') {
                this.decreaseClockHand();
            }
            else if (this.selectedTime.time <= 12) {
                this.increaseClockHand();
            }
        }
        this.clockHand.nativeElement.style.transform = `rotate(${this.selectedTime.angle}deg)`;
    }
    /**
     * @return {?}
     */
    selectAvailableTime() {
        const /** @type {?} */ currentTime = this.faceTime.find(time => this.selectedTime.time === time.time);
        this.isClockFaceDisabled = this.faceTime.every(time => time.disabled);
        if ((currentTime && currentTime.disabled) && !this.isClockFaceDisabled) {
            const /** @type {?} */ availableTime = this.faceTime.find(time => !time.disabled);
            this.timeChange.next(availableTime);
        }
    }
    /**
     * @param {?} x0
     * @param {?} y0
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    isInnerClockFace(x0, y0, x, y) {
        //Detect whether time from the inner clock face or not (24 format only)
        return Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)) < this.innerClockFaceSize;
    }
    /**
     * @return {?}
     */
    decreaseClockHand() {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.small.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.small.top;
    }
    /**
     * @return {?}
     */
    increaseClockHand() {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.large.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.large.top;
    }
}
NgxMaterialTimepickerFaceComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-face',
                template: `<div class="clock-face" #clockFace>
    <div *ngIf="unit !== timeUnit.MINUTE;else minutesFace" class="clock-face__container">
        <div class="clock-face__number clock-face__number--outer"
             [style.transform]="'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer"
             *ngFor="let time of faceTime.slice(0, 12); trackBy: trackByTime">
			<span [style.transform]="'rotateZ(-'+ time.angle +'deg)' | styleSanitizer"
                  [ngClass]="{'active': (time.time === selectedTime.time) && !isClockFaceDisabled, 'disabled': time.disabled}">{{time.time}}</span>
        </div>
        <div class="clock-face__inner" *ngIf="faceTime.length > 12"
             [style.top]="'calc(50% - ' + innerClockFaceSize + 'px)'">
            <div class="clock-face__number clock-face__number--inner"
                 [style.transform]="'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer"
                 [style.height.px]="innerClockFaceSize"
                 *ngFor="let time of faceTime.slice(12, 24); trackBy: trackByTime">
			<span [style.transform]="'rotateZ(-'+ time.angle +'deg)' | styleSanitizer"
                  [ngClass]="{'active': (time.time === selectedTime.time) && !isClockFaceDisabled, 'disabled': time.disabled}">
                {{time.time}}</span>
            </div>
        </div>
    </div>
    <span class="clock-face__clock-hand" [ngClass]="{'clock-face__clock-hand_minute': unit === timeUnit.MINUTE}"
          #clockHand [hidden]="isClockFaceDisabled"></span>
</div>
<ng-template #minutesFace>
    <div class="clock-face__container">
        <div class="clock-face__number clock-face__number--outer"
             [style.transform]="'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer"
             *ngFor="let time of faceTime; trackBy: trackByTime">
	<span [style.transform]="'rotateZ(-'+ time.angle +'deg)' | styleSanitizer"
          [ngClass]="{'active': ((selectedTime.time === time.time) && time.time % 5 === 0) && !isClockFaceDisabled, 'disabled': time.disabled}">
	{{time.time % 5 === 0 ? time.time : ''}}</span>
        </div>
    </div>
</ng-template>
`,
                styles: [`@import url(https://fonts.googleapis.com/css?family=Roboto:400,500,700);.clock-face{width:290px;height:290px;border-radius:50%;background-color:#f0f0f0;position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:20px;-webkit-box-sizing:border-box;box-sizing:border-box}.clock-face__inner{position:absolute}.clock-face__container{margin-left:-2px}.clock-face__number{position:absolute;-webkit-transform-origin:0 100%;transform-origin:0 100%;width:50px;text-align:center;z-index:2}.clock-face__number--outer{height:calc(290px / 2 - 20px)}.clock-face__number--outer>span{font-size:16px;color:#6c6c6c}.clock-face__number--inner>span{font-size:14px;color:#929292}.clock-face__number>span{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:30px;height:30px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:auto;border-radius:50%;font-weight:500;font-family:Roboto,sans-serif}.clock-face__number>span.active{background-color:#00bfff;color:#fff}.clock-face__number>span.disabled{color:#c5c5c5}.clock-face__clock-hand{height:103px;width:2px;background-color:#00bfff;-webkit-transform-origin:0 100%;transform-origin:0 100%;position:absolute;top:calc(50% - 103px);z-index:1}.clock-face__clock-hand:after{content:'';width:7px;height:7px;border-radius:50%;background-color:#00bfff;position:absolute;bottom:-3px;left:-3.5px}.clock-face__clock-hand_minute:before{content:'';width:7px;height:7px;background-color:#fff;border:4px solid #00bfff;border-radius:50%;position:absolute;top:-8px;left:calc(50% - 8px);-webkit-box-sizing:content-box;box-sizing:content-box}@media (max-width:1023px) and (orientation:landscape){.clock-face{width:225px;height:225px;padding:5px}.clock-face__number--outer{height:calc(225px / 2 - 5px)}.clock-face__clock-hand_minute:before{top:0}}`]
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerFaceComponent.ctorParameters = () => [];
NgxMaterialTimepickerFaceComponent.propDecorators = {
    "faceTime": [{ type: Input },],
    "selectedTime": [{ type: Input },],
    "unit": [{ type: Input },],
    "format": [{ type: Input },],
    "timeChange": [{ type: Output },],
    "clockFace": [{ type: ViewChild, args: ['clockFace',] },],
    "clockHand": [{ type: ViewChild, args: ['clockHand',] },],
    "onMousedown": [{ type: HostListener, args: ['touchstart', ['$event'],] }, { type: HostListener, args: ['mousedown', ['$event'],] },],
    "selectTime": [{ type: HostListener, args: ['click', ['$event'],] }, { type: HostListener, args: ['touchmove', ['$event.changedTouches[0]'],] }, { type: HostListener, args: ['touchend', ['$event.changedTouches[0]'],] }, { type: HostListener, args: ['mousemove', ['$event'],] },],
    "onMouseup": [{ type: HostListener, args: ['touchend', ['$event'],] }, { type: HostListener, args: ['mouseup', ['$event'],] },],
};
/**
 * @param {?} angle
 * @param {?} step
 * @return {?}
 */
function roundAngle(angle, step) {
    const /** @type {?} */ roundedAngle = Math.round(angle / step) * step;
    return roundedAngle === 0 ? 360 : roundedAngle;
}
/**
 * @param {?} x0
 * @param {?} y0
 * @param {?} x
 * @param {?} y
 * @param {?} currentAngle
 * @return {?}
 */
function countAngleByCords(x0, y0, x, y, currentAngle) {
    if (y > y0 && x >= x0) {
        // II quarter
        return 180 - currentAngle;
    }
    else if (y > y0 && x < x0) {
        // III quarter
        return 180 + currentAngle;
    }
    else if (y < y0 && x < x0) {
        // IV quarter
        return 360 - currentAngle;
    }
    else {
        // I quarter
        return currentAngle;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TimeFormatterPipe {
    /**
     * @param {?} time
     * @param {?} timeUnit
     * @return {?}
     */
    transform(time, timeUnit) {
        if (!time) {
            return time;
        }
        switch (timeUnit) {
            case TimeUnit.HOUR:
                return utc(time * 3600 * 1000).format('HH');
            case TimeUnit.MINUTE:
                return utc(time * 60 * 1000).format('mm');
        }
    }
}
TimeFormatterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'timeFormatter'
            },] },
];
/** @nocollapse */
TimeFormatterPipe.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMaterialTimepickerButtonComponent {
}
NgxMaterialTimepickerButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-button',
                template: `<button class="timepicker-button" type="button">
  <span><ng-content></ng-content></span>
</button>
`,
                styles: [`@import url(https://fonts.googleapis.com/css?family=Roboto:400,500,700);.timepicker-button{display:inline-block;height:36px;min-width:88px;line-height:36px;border:12px;border-radius:2px;background-color:transparent;color:#00bfff;text-align:center;-webkit-transition:all 450ms cubic-bezier(.23,1,.32,1);transition:all 450ms cubic-bezier(.23,1,.32,1);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;cursor:pointer;outline:0}.timepicker-button:focus,.timepicker-button:hover{background-color:rgba(153,153,153,.2)}.timepicker-button>span{font-size:14px;text-transform:uppercase;font-weight:600;padding-left:16px;padding-right:16px;font-family:Roboto,sans-serif}`]
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerButtonComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TimepickerDirective),
    multi: true
};
class TimepickerDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.onTouched = () => {
        };
        this.timepickerSubscriptions = [];
        this.onChange = () => {
        };
    }
    /**
     * @param {?} picker
     * @return {?}
     */
    set timepicker(picker) {
        this.registerTimepicker(picker);
    }
    /**
     * @return {?}
     */
    get format() {
        return this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        this._format = value === 24 ? 24 : 12;
    }
    /**
     * @return {?}
     */
    get min() {
        return this._min;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        if (typeof value === 'string') {
            this._min = TimeAdapter.convertTimeToMoment(value);
            return;
        }
        this._min = value;
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        if (typeof value === 'string') {
            this._max = TimeAdapter.convertTimeToMoment(value);
            return;
        }
        this._max = value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!value) {
            return;
        }
        this._value = TimeAdapter.formatTime(value, this._format);
        if (this.isValueAvailableToUpdate()) {
            this.updateInputValue();
            return;
        }
        console.warn('Selected time doesn\'t match min or max value');
    }
    /**
     * @param {?} time
     * @return {?}
     */
    set defaultTime(time) {
        if (this.isValueAvailableToUpdate()) {
            this._timepicker.setDefaultTime(TimeAdapter.formatTime(time, this._format));
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onInput(value) {
        this._value = value;
        this.onChange(value);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['value'] && changes['value'].currentValue) {
            this.defaultTime = changes['value'].currentValue;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (!this.disableClick) {
            this._timepicker.open();
            event.stopPropagation();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
        this.defaultTime = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.timepickerSubscriptions.forEach(s => s.unsubscribe());
    }
    /**
     * @param {?} picker
     * @return {?}
     */
    registerTimepicker(picker) {
        if (picker) {
            this._timepicker = picker;
            this._timepicker.registerInput(this);
            this.timepickerSubscriptions.push(this._timepicker.timeSet.subscribe((time) => {
                this.value = time;
                this.onChange(this._value);
                this.onTouched();
            }));
            this.timepickerSubscriptions.push(this._timepicker.closed.subscribe(() => this.defaultTime = this._value));
        }
    }
    /**
     * @return {?}
     */
    updateInputValue() {
        this.elementRef.nativeElement.value = this._value;
    }
    /**
     * @return {?}
     */
    isValueAvailableToUpdate() {
        const /** @type {?} */ isAfter = this._min && TimeAdapter.convertTimeToMoment(this._value).isAfter(this._min);
        const /** @type {?} */ isBefore = this._max && TimeAdapter.convertTimeToMoment(this._value).isBefore(this._max);
        const /** @type {?} */ isBetween = (this._min && this._max)
            && TimeAdapter.convertTimeToMoment(this._value).isBetween(this._min, this._max, 'minutes');
        const /** @type {?} */ isAvailable = !this._min && !this._max;
        return isAfter || isBefore || isBetween || isAvailable;
    }
}
TimepickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngxTimepicker]',
                providers: [VALUE_ACCESSOR],
                host: {
                    '[disabled]': 'disabled',
                    '(input)': 'onInput($event.target.value)',
                    '(blur)': 'onTouched()',
                },
            },] },
];
/** @nocollapse */
TimepickerDirective.ctorParameters = () => [
    { type: ElementRef, },
];
TimepickerDirective.propDecorators = {
    "disabled": [{ type: Input },],
    "disableClick": [{ type: Input },],
    "timepicker": [{ type: Input, args: ['ngxTimepicker',] },],
    "format": [{ type: Input },],
    "min": [{ type: Input },],
    "max": [{ type: Input },],
    "value": [{ type: Input },],
    "onClick": [{ type: HostListener, args: ['click', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class OverlayDirective {
    /**
     * @param {?} eventService
     */
    constructor(eventService) {
        this.eventService = eventService;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        this.eventService.backdropClickSubject.next(e);
        e.preventDefault();
    }
}
OverlayDirective.decorators = [
    { type: Directive, args: [{
                selector: '[overlay]'
            },] },
];
/** @nocollapse */
OverlayDirective.ctorParameters = () => [
    { type: NgxMaterialTimepickerEventService, },
];
OverlayDirective.propDecorators = {
    "onClick": [{ type: HostListener, args: ['click', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FocusAnchorDirective {
    /**
     * @param {?} document
     * @param {?} elementRef
     */
    constructor(document, elementRef) {
        this.document = document;
        this.element = elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.activeElement = /** @type {?} */ (this.document.activeElement);
        // To avoid an error ExpressionChangedAfterItHasBeenCheckedError
        setTimeout(() => this.element.focus());
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // To avoid an error ExpressionChangedAfterItHasBeenCheckedError
        setTimeout(() => this.activeElement.focus());
    }
}
FocusAnchorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[focusAnchor]'
            },] },
];
/** @nocollapse */
FocusAnchorDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] },] },
    { type: ElementRef, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMaterialTimepickerToggleIconDirective {
}
NgxMaterialTimepickerToggleIconDirective.decorators = [
    { type: Directive, args: [{ selector: '[ngxMaterialTimepickerToggleIcon]' },] },
];
/** @nocollapse */
NgxMaterialTimepickerToggleIconDirective.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMaterialTimepickerToggleComponent {
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled === undefined ? this.timepicker.disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    open(event) {
        if (this.timepicker) {
            this.timepicker.open();
            event.stopPropagation();
        }
    }
}
NgxMaterialTimepickerToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-toggle',
                template: `<button class="ngx-material-timepicker-toggle" (click)="open($event)" [disabled]="disabled" type="button">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24px" height="24px" *ngIf="!customIcon">
        <path
            d="M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z"/>
    </svg>
    <ng-content select="[ngxMaterialTimepickerToggleIcon]"></ng-content>
</button>
`,
                styles: [`.ngx-material-timepicker-toggle{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:4px;background-color:transparent;border-radius:50%;text-align:center;border:none;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-transition:background-color .3s;transition:background-color .3s;cursor:pointer}.ngx-material-timepicker-toggle:focus{background-color:rgba(0,0,0,.07)}`]
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerToggleComponent.ctorParameters = () => [];
NgxMaterialTimepickerToggleComponent.propDecorators = {
    "timepicker": [{ type: Input, args: ['for',] },],
    "disabled": [{ type: Input },],
    "customIcon": [{ type: ContentChild, args: [NgxMaterialTimepickerToggleIconDirective,] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 */
class NgxMaterialTimepickerHoursFaceComponent {
    /**
     * @param {?} hours
     */
    constructor(hours) {
        this.hourChange = new EventEmitter();
        this.hourSelected = new EventEmitter();
        this.hoursList = [];
        this.initHours(hours);
    }
    /**
     * @return {?}
     */
    onClick() {
        this.hourSelected.next();
    }
    /**
     * @param {?} hours
     * @return {?}
     */
    initHours(hours) {
        const /** @type {?} */ angleStep = 30;
        this.hoursList = Array(hours).fill(1).map((v, i) => {
            const /** @type {?} */ time = v + i;
            return { time: time === 24 ? '00' : time, angle: angleStep * time };
        });
    }
}
NgxMaterialTimepickerHoursFaceComponent.propDecorators = {
    "selectedHour": [{ type: Input },],
    "minTime": [{ type: Input },],
    "maxTime": [{ type: Input },],
    "hourChange": [{ type: Output },],
    "hourSelected": [{ type: Output },],
    "onClick": [{ type: HostListener, args: ['touchend',] }, { type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const moment$3 = _moment;
class NgxMaterialTimepicker12HoursFaceComponent extends NgxMaterialTimepickerHoursFaceComponent {
    constructor() {
        super(12);
    }
    /**
     * @return {?}
     */
    get disabledHours() {
        if (this.minTime || this.maxTime) {
            return this.hoursList.map(value => {
                const /** @type {?} */ currentHour = this.period === TimePeriod.AM ? +value.time : +value.time + 12;
                const /** @type {?} */ hour = this.period === TimePeriod.AM && currentHour === 12 ? 0 : currentHour;
                const /** @type {?} */ currentTime = moment$3().hour(hour);
                return Object.assign({}, value, { disabled: currentTime.isBefore(this.minTime || null, 'hours')
                        || currentTime.isAfter(this.maxTime || null, 'hours') });
            });
        }
        return this.hoursList;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['period'] && changes['period'].currentValue) {
            this.hoursList = this.disabledHours;
        }
    }
}
NgxMaterialTimepicker12HoursFaceComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-12-hours-face',
                template: `<ngx-material-timepicker-face [selectedTime]="selectedHour" [faceTime]="hoursList"
                              (timeChange)="hourChange.next($event)"></ngx-material-timepicker-face>
`
            },] },
];
/** @nocollapse */
NgxMaterialTimepicker12HoursFaceComponent.ctorParameters = () => [];
NgxMaterialTimepicker12HoursFaceComponent.propDecorators = {
    "period": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const moment$4 = _moment;
class NgxMaterialTimepicker24HoursFaceComponent extends NgxMaterialTimepickerHoursFaceComponent {
    constructor() {
        super(24);
    }
    /**
     * @return {?}
     */
    get disabledHours() {
        if (this.minTime || this.maxTime) {
            return this.hoursList.map(value => {
                const /** @type {?} */ currentTime = moment$4().hour(+value.time);
                return Object.assign({}, value, { disabled: currentTime.isBefore(this.minTime || null, 'hours')
                        || currentTime.isAfter(this.maxTime || null, 'hours') });
            });
        }
        return this.hoursList;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.hoursList = this.disabledHours;
    }
}
NgxMaterialTimepicker24HoursFaceComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-24-hours-face',
                template: `<ngx-material-timepicker-face [selectedTime]="selectedHour" [faceTime]="hoursList" [format]="format"
                              (timeChange)="hourChange.next($event)"></ngx-material-timepicker-face>
`
            },] },
];
/** @nocollapse */
NgxMaterialTimepicker24HoursFaceComponent.ctorParameters = () => [];
NgxMaterialTimepicker24HoursFaceComponent.propDecorators = {
    "format": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMaterialTimepickerModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxMaterialTimepickerModule,
            providers: [NgxMaterialTimepickerService, NgxMaterialTimepickerEventService]
        };
    }
}
NgxMaterialTimepickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    NgxMaterialTimepickerComponent,
                    NgxMaterialTimepickerToggleComponent,
                    TimepickerDirective,
                    NgxMaterialTimepickerToggleIconDirective
                ],
                declarations: [
                    NgxMaterialTimepickerComponent,
                    NgxMaterialTimepicker24HoursFaceComponent,
                    NgxMaterialTimepicker12HoursFaceComponent,
                    NgxMaterialTimepickerMinutesFaceComponent,
                    NgxMaterialTimepickerFaceComponent,
                    NgxMaterialTimepickerToggleComponent,
                    StyleSanitizerPipe,
                    TimeFormatterPipe,
                    NgxMaterialTimepickerButtonComponent,
                    TimepickerDirective,
                    OverlayDirective,
                    FocusAnchorDirective,
                    NgxMaterialTimepickerToggleIconDirective
                ]
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgxMaterialTimepickerModule, NgxMaterialTimepicker12HoursFaceComponent as j, NgxMaterialTimepicker24HoursFaceComponent as h, NgxMaterialTimepickerButtonComponent as o, NgxMaterialTimepickerFaceComponent as l, NgxMaterialTimepickerHoursFaceComponent as i, NgxMaterialTimepickerMinutesFaceComponent as k, NgxMaterialTimepickerToggleComponent as e, FocusAnchorDirective as q, NgxMaterialTimepickerToggleIconDirective as f, TimepickerDirective as g, OverlayDirective as p, AnimationState as a, NgxMaterialTimepickerComponent as b, StyleSanitizerPipe as m, TimeFormatterPipe as n, NgxMaterialTimepickerEventService as d, NgxMaterialTimepickerService as c };
//# sourceMappingURL=ngx-material-timepicker.js.map
