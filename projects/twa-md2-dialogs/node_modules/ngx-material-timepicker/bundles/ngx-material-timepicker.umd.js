(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment'), require('@angular/core'), require('rxjs'), require('@angular/animations'), require('rxjs/operators'), require('@angular/platform-browser'), require('@angular/forms'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define(['exports', 'moment', '@angular/core', 'rxjs', '@angular/animations', 'rxjs/operators', '@angular/platform-browser', '@angular/forms', '@angular/common'], factory) :
	(factory((global['ngx-material-timepicker'] = {}),global._moment,global.ng.core,global.rxjs,global.ng.animations,global.Rx.Observable.prototype,global.ng.platformBrowser,global.ng.forms,global.ng.common));
}(this, (function (exports,_moment,core,rxjs,animations,operators,platformBrowser,forms,common) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */
var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var TimePeriod = {
    AM: 'AM',
    PM: 'PM',
};
var TimeFormat = {
    TWELVE: 'hh:mm a',
    TWENTY_FOUR: 'HH:mm',
};
var moment = _moment;
var TimeAdapter = /** @class */ (function () {
    function TimeAdapter() {
    }
    TimeAdapter.formatTime = function (time, format) {
        if (format === void 0) { format = 12; }
        var timeFormat = format === 24 ? TimeFormat.TWENTY_FOUR : TimeFormat.TWELVE;
        return moment(time, timeFormat).format(timeFormat);
    };
    TimeAdapter.convertTimeToMoment = function (time) {
        return moment(time, TimeFormat.TWELVE);
    };
    return TimeAdapter;
}());
var moment$1 = _moment;
var DEFAULT_HOUR = {
    time: 12,
    angle: 360
};
var DEFAULT_MINUTE = {
    time: '00',
    angle: 360
};
var NgxMaterialTimepickerService = /** @class */ (function () {
    function NgxMaterialTimepickerService() {
        this.hourSubject = new rxjs.BehaviorSubject(DEFAULT_HOUR);
        this.minuteSubject = new rxjs.BehaviorSubject(DEFAULT_MINUTE);
        this.periodSubject = new rxjs.BehaviorSubject(TimePeriod.AM);
    }
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "hour", {
        set: function (hour) {
            this.hourSubject.next(hour);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "selectedHour", {
        get: function () {
            return this.hourSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "minute", {
        set: function (minute) {
            this.minuteSubject.next(minute);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "selectedMinute", {
        get: function () {
            return this.minuteSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "period", {
        set: function (period) {
            this.periodSubject.next(period);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "selectedPeriod", {
        get: function () {
            return this.periodSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "defaultTime", {
        set: function (time) {
            var defaultTime = moment$1(time, TimeFormat.TWENTY_FOUR).toDate();
            if (moment$1(defaultTime).isValid()) {
                this.hour = Object.assign({}, DEFAULT_HOUR, { time: defaultTime.getHours() === 0 ? '00' : defaultTime.getHours() });
                this.minute = Object.assign({}, DEFAULT_MINUTE, { time: defaultTime.getMinutes() === 0 ? '00' : defaultTime.getMinutes() });
                this.period = (time.substr(time.length - 2).toUpperCase());
            }
            else {
                this.resetTime();
            }
        },
        enumerable: true,
        configurable: true
    });
    NgxMaterialTimepickerService.prototype.getFullTime = function (format) {
        var hour = this.hourSubject.getValue().time;
        var minute = this.minuteSubject.getValue().time;
        var period = this.periodSubject.getValue();
        return TimeAdapter.formatTime(hour + ":" + minute + " " + period, format);
    };
    NgxMaterialTimepickerService.prototype.resetTime = function () {
        this.hour = Object.assign({}, DEFAULT_HOUR);
        this.minute = Object.assign({}, DEFAULT_MINUTE);
        this.period = TimePeriod.AM;
    };
    return NgxMaterialTimepickerService;
}());
NgxMaterialTimepickerService.decorators = [
    { type: core.Injectable },
];
NgxMaterialTimepickerService.ctorParameters = function () { return []; };
var TimeUnit = {
    HOUR: 0,
    MINUTE: 1,
};
TimeUnit[TimeUnit.HOUR] = "HOUR";
TimeUnit[TimeUnit.MINUTE] = "MINUTE";
var NgxMaterialTimepickerEventService = /** @class */ (function () {
    function NgxMaterialTimepickerEventService() {
        this.backdropClickSubject = new rxjs.Subject();
        this.keydownEventSubject = new rxjs.Subject();
    }
    Object.defineProperty(NgxMaterialTimepickerEventService.prototype, "backdropClick", {
        get: function () {
            return this.backdropClickSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerEventService.prototype, "keydownEvent", {
        get: function () {
            return this.keydownEventSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    return NgxMaterialTimepickerEventService;
}());
NgxMaterialTimepickerEventService.decorators = [
    { type: core.Injectable },
];
NgxMaterialTimepickerEventService.ctorParameters = function () { return []; };
var AnimationState = {
    ENTER: 'enter',
    LEAVE: 'leave',
};
var ESCAPE = 27;
var NgxMaterialTimepickerComponent = /** @class */ (function () {
    function NgxMaterialTimepickerComponent(timepickerService, eventService) {
        var _this = this;
        this.timepickerService = timepickerService;
        this.eventService = eventService;
        this.timePeriod = TimePeriod;
        this.timeUnit = TimeUnit;
        this.activeTimeUnit = TimeUnit.HOUR;
        this.isOpened = false;
        this.subscriptions = [];
        this.isEsc = true;
        this.timeSet = new core.EventEmitter();
        this.closed = new core.EventEmitter();
        this.subscriptions.push(rxjs.merge(this.eventService.backdropClick, this.eventService.keydownEvent.pipe(operators.filter(function (e) { return e.keyCode === ESCAPE && _this.isEsc; })))
            .subscribe(function () { return _this.close(); }));
    }
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "minTime", {
        get: function () {
            return this.timepickerInput && this.timepickerInput.min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "maxTime", {
        get: function () {
            return this.timepickerInput && this.timepickerInput.max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "disabled", {
        get: function () {
            return this.timepickerInput && this.timepickerInput.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "format", {
        get: function () {
            return this.timepickerInput && this.timepickerInput.format;
        },
        enumerable: true,
        configurable: true
    });
    NgxMaterialTimepickerComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscriptions.push(this.timepickerService.selectedHour
            .subscribe(function (hour) { return _this.selectedHour = hour; }));
        this.subscriptions.push(this.timepickerService.selectedMinute
            .subscribe(function (minute) { return _this.selectedMinute = minute; }));
        this.subscriptions.push(this.timepickerService.selectedPeriod
            .subscribe(function (period) { return _this.selectedPeriod = period; }));
    };
    NgxMaterialTimepickerComponent.prototype.registerInput = function (input) {
        if (this.timepickerInput) {
            throw Error('A Timepicker can only be associated with a single input.');
        }
        this.timepickerInput = input;
    };
    NgxMaterialTimepickerComponent.prototype.onHourChange = function (hour) {
        this.timepickerService.hour = hour;
    };
    NgxMaterialTimepickerComponent.prototype.onMinuteChange = function (minute) {
        this.timepickerService.minute = minute;
    };
    NgxMaterialTimepickerComponent.prototype.changePeriod = function (period) {
        this.timepickerService.period = period;
    };
    NgxMaterialTimepickerComponent.prototype.changeTimeUnit = function (unit) {
        this.activeTimeUnit = unit;
    };
    NgxMaterialTimepickerComponent.prototype.setTime = function () {
        this.timeSet.next(this.timepickerService.getFullTime(this.format));
        this.close();
    };
    NgxMaterialTimepickerComponent.prototype.setDefaultTime = function (time) {
        this.timepickerService.defaultTime = time;
    };
    NgxMaterialTimepickerComponent.prototype.open = function () {
        this.isOpened = true;
        this.animationState = AnimationState.ENTER;
    };
    NgxMaterialTimepickerComponent.prototype.close = function () {
        this.animationState = AnimationState.LEAVE;
    };
    NgxMaterialTimepickerComponent.prototype.animationDone = function (event) {
        if (event.phaseName === 'done' && event.toState === AnimationState.LEAVE) {
            this.isOpened = false;
            this.activeTimeUnit = TimeUnit.HOUR;
            this.closed.next();
        }
    };
    NgxMaterialTimepickerComponent.prototype.onKeydown = function (e) {
        this.eventService.keydownEventSubject.next(e);
        e.stopPropagation();
    };
    NgxMaterialTimepickerComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.forEach(function (subscription) { return subscription.unsubscribe(); });
    };
    return NgxMaterialTimepickerComponent;
}());
NgxMaterialTimepickerComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-material-timepicker',
                template: "<div class=\"timepicker-backdrop-overlay\" *ngIf=\"isOpened\" overlay></div>\n<div class=\"timepicker-overlay\" *ngIf=\"isOpened\">\n    <div class=\"timepicker\" [@timepicker]=\"animationState\" (@timepicker.done)=\"animationDone($event)\" tabindex=\"0\"\n         focusAnchor>\n        <header class=\"timepicker__header\">\n            <div class=\"timepicker-dial\">\n                <div class=\"timepicker-dial__time\">\n\t\t\t\t<span class=\"timepicker-dial__item\"\n                      [ngClass]=\"{'timepicker-dial__item_active': activeTimeUnit === timeUnit.HOUR}\"\n                      (click)=\"changeTimeUnit(timeUnit.HOUR)\">\n\t\t\t\t\t{{selectedHour?.time | timeFormatter: timeUnit.HOUR}}</span>:<span\n                    class=\"timepicker-dial__item\"\n                    [ngClass]=\"{'timepicker-dial__item_active': activeTimeUnit === timeUnit.MINUTE}\"\n                    (click)=\"changeTimeUnit(timeUnit.MINUTE)\">{{selectedMinute?.time | timeFormatter: timeUnit.MINUTE}}</span>\n                </div>\n                <div class=\"timepicker-dial__period\" *ngIf=\"format !== 24\">\n\t\t\t<span class=\"timepicker-dial__item\"\n                  [ngClass]=\"{'timepicker-dial__item_active': selectedPeriod === timePeriod.AM}\"\n                  (click)=\"changePeriod(timePeriod.AM)\">AM</span>\n                    <span class=\"timepicker-dial__item\"\n                          [ngClass]=\"{'timepicker-dial__item_active': selectedPeriod === timePeriod.PM}\"\n                          (click)=\"changePeriod(timePeriod.PM)\">PM</span>\n                </div>\n            </div>\n        </header>\n        <div class=\"timepicker__main-content\">\n            <div class=\"timepicker__body\" [ngSwitch]=\"activeTimeUnit\">\n                <div *ngSwitchCase=\"timeUnit.HOUR\">\n                    <ngx-material-timepicker-24-hours-face *ngIf=\"format === 24;else ampmHours\"\n                                                           (hourChange)=\"onHourChange($event)\"\n                                                           [selectedHour]=\"selectedHour\"\n                                                           [minTime]=\"minTime\"\n                                                           [maxTime]=\"maxTime\"\n                                                           [format]=\"format\"\n                                                           (hourSelected)=\"activeTimeUnit = timeUnit.MINUTE\"></ngx-material-timepicker-24-hours-face>\n                    <ng-template #ampmHours>\n                        <ngx-material-timepicker-12-hours-face\n                            (hourChange)=\"onHourChange($event)\"\n                            [selectedHour]=\"selectedHour\"\n                            [period]=\"selectedPeriod\"\n                            [minTime]=\"minTime\"\n                            [maxTime]=\"maxTime\"\n                            (hourSelected)=\"activeTimeUnit = timeUnit.MINUTE\"></ngx-material-timepicker-12-hours-face>\n                    </ng-template>\n                </div>\n                <ngx-material-timepicker-minutes-face *ngSwitchCase=\"timeUnit.MINUTE\"\n                                                      [selectedMinute]=\"selectedMinute\"\n                                                      [selectedHour]=\"selectedHour?.time\"\n                                                      [minTime]=\"minTime\"\n                                                      [maxTime]=\"maxTime\"\n                                                      [period]=\"selectedPeriod\"\n                                                      (minuteChange)=\"onMinuteChange($event)\"></ngx-material-timepicker-minutes-face>\n            </div>\n            <div class=\"timepicker__actions\">\n                <div (click)=\"close()\">\n                    <ng-container *ngTemplateOutlet=\"cancelBtnTmpl ? cancelBtnTmpl : cancelBtnDefault\"></ng-container>\n                </div>\n                <div (click)=\"setTime()\">\n                    <ng-container\n                        *ngTemplateOutlet=\"confirmBtnTmpl ? confirmBtnTmpl : confirmBtnDefault\"></ng-container>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n<ng-template #cancelBtnDefault>\n    <ngx-material-timepicker-button>Cancel</ngx-material-timepicker-button>\n</ng-template>\n<ng-template #confirmBtnDefault>\n    <ngx-material-timepicker-button>Ok</ngx-material-timepicker-button>\n</ng-template>\n",
                styles: ["@import url(https://fonts.googleapis.com/css?family=Roboto:400,500,700);.timepicker-backdrop-overlay{position:fixed;top:0;bottom:0;right:0;left:0;background-color:rgba(0,0,0,.3);z-index:999;pointer-events:auto}.timepicker-overlay{position:fixed;top:0;left:0;width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;z-index:999;pointer-events:none}.timepicker{width:300px;border-radius:2px;-webkit-box-shadow:rgba(0,0,0,.25) 0 14px 45px,rgba(0,0,0,.22) 0 10px 18px;box-shadow:rgba(0,0,0,.25) 0 14px 45px,rgba(0,0,0,.22) 0 10px 18px;outline:0;position:static;z-index:999;pointer-events:auto}.timepicker__header{background-color:#00bfff;padding:15px 30px}.timepicker__body{background-color:#fff;padding:15px 5px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.timepicker__actions{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;padding:15px;background-color:#fff}.timepicker-dial{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;-webkit-tap-highlight-color:transparent}.timepicker-dial__time{line-height:normal;font-size:50px;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.timepicker-dial__period{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin-left:10px;font-size:18px;font-weight:500;font-family:Roboto,sans-serif;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.timepicker-dial__item{cursor:pointer;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}.timepicker-dial__item_active{color:#fff}@media (max-width:1023px) and (orientation:landscape){.timepicker{display:-webkit-box;display:-ms-flexbox;display:flex;width:515px}.timepicker__header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.timepicker__main-content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;width:100%}.timepicker__actions{padding:5px;margin-top:-1px}.timepicker-dial{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.timepicker-dial__period{margin-left:0}}"],
                animations: [
                    animations.trigger('timepicker', [
                        animations.transition("* => " + AnimationState.ENTER, [
                            animations.style({ transform: 'translateY(-30%)' }),
                            animations.animate('0.2s ease-out', animations.style({ transform: 'translateY(0)' }))
                        ]),
                        animations.transition(AnimationState.ENTER + " => " + AnimationState.LEAVE, [
                            animations.style({ transform: 'translateY(0)', opacity: 1 }),
                            animations.animate('0.2s ease-out', animations.style({ transform: 'translateY(-30%)', opacity: 0 }))
                        ])
                    ])
                ],
                providers: [NgxMaterialTimepickerService]
            },] },
];
NgxMaterialTimepickerComponent.ctorParameters = function () { return [
    { type: NgxMaterialTimepickerService, },
    { type: NgxMaterialTimepickerEventService, },
]; };
NgxMaterialTimepickerComponent.propDecorators = {
    "cancelBtnTmpl": [{ type: core.Input },],
    "confirmBtnTmpl": [{ type: core.Input },],
    "isEsc": [{ type: core.Input, args: ['ESC',] },],
    "timeSet": [{ type: core.Output },],
    "closed": [{ type: core.Output },],
    "onKeydown": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],
};
var StyleSanitizerPipe = /** @class */ (function () {
    function StyleSanitizerPipe(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    StyleSanitizerPipe.prototype.transform = function (value) {
        if (!value) {
            return value;
        }
        return this.domSanitizer.bypassSecurityTrustStyle(value);
    };
    return StyleSanitizerPipe;
}());
StyleSanitizerPipe.decorators = [
    { type: core.Pipe, args: [{
                name: 'styleSanitizer'
            },] },
];
StyleSanitizerPipe.ctorParameters = function () { return [
    { type: platformBrowser.DomSanitizer, },
]; };
var moment$2 = _moment;
var MINUTES = 60;
var NgxMaterialTimepickerMinutesFaceComponent = /** @class */ (function () {
    function NgxMaterialTimepickerMinutesFaceComponent() {
        this.minutesList = [];
        this.timeUnit = TimeUnit;
        this.minuteChange = new core.EventEmitter();
        var angleStep = 360 / MINUTES;
        this.minutesList = Array(MINUTES).fill(0).map(function (v, i) {
            var index = (v + i);
            var angle = angleStep * index;
            return { time: index === 0 ? '00' : index, angle: angle !== 0 ? angle : 360 };
        });
    }
    Object.defineProperty(NgxMaterialTimepickerMinutesFaceComponent.prototype, "selectedHour", {
        set: function (value) {
            this._selectedHour = value === 12 ? 0 : value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerMinutesFaceComponent.prototype, "disabledMinutes", {
        get: function () {
            var _this = this;
            if (this.minTime || this.maxTime) {
                return this.minutesList.map(function (value) {
                    var hour = _this.period === TimePeriod.AM ? _this._selectedHour : _this._selectedHour + 12;
                    var currentTime = moment$2().hour(hour).minute(+value.time);
                    return Object.assign({}, value, { disabled: currentTime.isBefore(_this.minTime || null, 'minutes')
                            || currentTime.isAfter(_this.maxTime || null, 'minutes') });
                });
            }
            return this.minutesList;
        },
        enumerable: true,
        configurable: true
    });
    NgxMaterialTimepickerMinutesFaceComponent.prototype.ngOnChanges = function (changes) {
        if (changes['period'] && changes['period'].currentValue) {
            this.minutesList = this.disabledMinutes;
        }
    };
    return NgxMaterialTimepickerMinutesFaceComponent;
}());
NgxMaterialTimepickerMinutesFaceComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-material-timepicker-minutes-face',
                template: "<ngx-material-timepicker-face [faceTime]=\"minutesList\" [selectedTime]=\"selectedMinute\"\n                              (timeChange)=\"minuteChange.next($event)\" [unit]=\"timeUnit.MINUTE\"></ngx-material-timepicker-face>\n"
            },] },
];
NgxMaterialTimepickerMinutesFaceComponent.ctorParameters = function () { return []; };
NgxMaterialTimepickerMinutesFaceComponent.propDecorators = {
    "selectedMinute": [{ type: core.Input },],
    "period": [{ type: core.Input },],
    "minTime": [{ type: core.Input },],
    "maxTime": [{ type: core.Input },],
    "selectedHour": [{ type: core.Input },],
    "minuteChange": [{ type: core.Output },],
};
var CLOCK_HAND_STYLES = {
    small: {
        height: '75px',
        top: 'calc(50% - 75px)'
    },
    large: {
        height: '103px',
        top: 'calc(50% - 103px)'
    }
};
var NgxMaterialTimepickerFaceComponent = /** @class */ (function () {
    function NgxMaterialTimepickerFaceComponent() {
        this.timeUnit = TimeUnit;
        this.innerClockFaceSize = 85;
        this.timeChange = new core.EventEmitter();
    }
    NgxMaterialTimepickerFaceComponent.prototype.ngAfterViewInit = function () {
        this.setClockHandPosition();
    };
    NgxMaterialTimepickerFaceComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if ((changes['faceTime'] && changes['faceTime'].currentValue)
            && (changes['selectedTime'] && changes['selectedTime'].currentValue)) {
            this.selectedTime = this.faceTime.find(function (time) { return time.time === _this.selectedTime.time; });
        }
        if (changes['selectedTime'] && changes['selectedTime'].currentValue) {
            this.setClockHandPosition();
        }
        if (changes['faceTime'] && changes['faceTime'].currentValue) {
            setTimeout(function () { return _this.selectAvailableTime(); });
        }
    };
    NgxMaterialTimepickerFaceComponent.prototype.trackByTime = function (_, time) {
        return time.time;
    };
    NgxMaterialTimepickerFaceComponent.prototype.onMousedown = function (e) {
        e.preventDefault();
        this.isStarted = true;
    };
    NgxMaterialTimepickerFaceComponent.prototype.selectTime = function (e) {
        if (!this.isStarted && (e instanceof MouseEvent && e.type !== 'click')) {
            return;
        }
        var clockFaceCords = this.clockFace.nativeElement.getBoundingClientRect();
        var centerX = clockFaceCords.left + clockFaceCords.width / 2;
        var centerY = clockFaceCords.top + clockFaceCords.height / 2;
        var arctangent = Math.atan(Math.abs(e.clientX - centerX) / Math.abs(e.clientY - centerY)) * 180 / Math.PI;
        var circleAngle = countAngleByCords(centerX, centerY, e.clientX, e.clientY, arctangent);
        var isInnerClockChosen = this.format && this.isInnerClockFace(centerX, centerY, e.clientX, e.clientY);
        var angleStep = this.unit === TimeUnit.MINUTE ? 6 : 30;
        var roundedAngle = isInnerClockChosen
            ? roundAngle(circleAngle, angleStep) + 360
            : roundAngle(circleAngle, angleStep);
        var selectedTime = this.faceTime.find(function (val) { return val.angle === roundedAngle; });
        if (!selectedTime.disabled) {
            this.timeChange.next(selectedTime);
        }
    };
    NgxMaterialTimepickerFaceComponent.prototype.onMouseup = function (e) {
        e.preventDefault();
        this.isStarted = false;
    };
    NgxMaterialTimepickerFaceComponent.prototype.setClockHandPosition = function () {
        if (this.format === 24) {
            if (this.selectedTime.time > 12 || this.selectedTime.time === '00') {
                this.decreaseClockHand();
            }
            else if (this.selectedTime.time <= 12) {
                this.increaseClockHand();
            }
        }
        this.clockHand.nativeElement.style.transform = "rotate(" + this.selectedTime.angle + "deg)";
    };
    NgxMaterialTimepickerFaceComponent.prototype.selectAvailableTime = function () {
        var _this = this;
        var currentTime = this.faceTime.find(function (time) { return _this.selectedTime.time === time.time; });
        this.isClockFaceDisabled = this.faceTime.every(function (time) { return time.disabled; });
        if ((currentTime && currentTime.disabled) && !this.isClockFaceDisabled) {
            var availableTime = this.faceTime.find(function (time) { return !time.disabled; });
            this.timeChange.next(availableTime);
        }
    };
    NgxMaterialTimepickerFaceComponent.prototype.isInnerClockFace = function (x0, y0, x, y) {
        return Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)) < this.innerClockFaceSize;
    };
    NgxMaterialTimepickerFaceComponent.prototype.decreaseClockHand = function () {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.small.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.small.top;
    };
    NgxMaterialTimepickerFaceComponent.prototype.increaseClockHand = function () {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.large.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.large.top;
    };
    return NgxMaterialTimepickerFaceComponent;
}());
NgxMaterialTimepickerFaceComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-material-timepicker-face',
                template: "<div class=\"clock-face\" #clockFace>\n    <div *ngIf=\"unit !== timeUnit.MINUTE;else minutesFace\" class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [style.transform]=\"'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer\"\n             *ngFor=\"let time of faceTime.slice(0, 12); trackBy: trackByTime\">\n\t\t\t<span [style.transform]=\"'rotateZ(-'+ time.angle +'deg)' | styleSanitizer\"\n                  [ngClass]=\"{'active': (time.time === selectedTime.time) && !isClockFaceDisabled, 'disabled': time.disabled}\">{{time.time}}</span>\n        </div>\n        <div class=\"clock-face__inner\" *ngIf=\"faceTime.length > 12\"\n             [style.top]=\"'calc(50% - ' + innerClockFaceSize + 'px)'\">\n            <div class=\"clock-face__number clock-face__number--inner\"\n                 [style.transform]=\"'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer\"\n                 [style.height.px]=\"innerClockFaceSize\"\n                 *ngFor=\"let time of faceTime.slice(12, 24); trackBy: trackByTime\">\n\t\t\t<span [style.transform]=\"'rotateZ(-'+ time.angle +'deg)' | styleSanitizer\"\n                  [ngClass]=\"{'active': (time.time === selectedTime.time) && !isClockFaceDisabled, 'disabled': time.disabled}\">\n                {{time.time}}</span>\n            </div>\n        </div>\n    </div>\n    <span class=\"clock-face__clock-hand\" [ngClass]=\"{'clock-face__clock-hand_minute': unit === timeUnit.MINUTE}\"\n          #clockHand [hidden]=\"isClockFaceDisabled\"></span>\n</div>\n<ng-template #minutesFace>\n    <div class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [style.transform]=\"'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer\"\n             *ngFor=\"let time of faceTime; trackBy: trackByTime\">\n\t<span [style.transform]=\"'rotateZ(-'+ time.angle +'deg)' | styleSanitizer\"\n          [ngClass]=\"{'active': ((selectedTime.time === time.time) && time.time % 5 === 0) && !isClockFaceDisabled, 'disabled': time.disabled}\">\n\t{{time.time % 5 === 0 ? time.time : ''}}</span>\n        </div>\n    </div>\n</ng-template>\n",
                styles: ["@import url(https://fonts.googleapis.com/css?family=Roboto:400,500,700);.clock-face{width:290px;height:290px;border-radius:50%;background-color:#f0f0f0;position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:20px;-webkit-box-sizing:border-box;box-sizing:border-box}.clock-face__inner{position:absolute}.clock-face__container{margin-left:-2px}.clock-face__number{position:absolute;-webkit-transform-origin:0 100%;transform-origin:0 100%;width:50px;text-align:center;z-index:2}.clock-face__number--outer{height:calc(290px / 2 - 20px)}.clock-face__number--outer>span{font-size:16px;color:#6c6c6c}.clock-face__number--inner>span{font-size:14px;color:#929292}.clock-face__number>span{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:30px;height:30px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:auto;border-radius:50%;font-weight:500;font-family:Roboto,sans-serif}.clock-face__number>span.active{background-color:#00bfff;color:#fff}.clock-face__number>span.disabled{color:#c5c5c5}.clock-face__clock-hand{height:103px;width:2px;background-color:#00bfff;-webkit-transform-origin:0 100%;transform-origin:0 100%;position:absolute;top:calc(50% - 103px);z-index:1}.clock-face__clock-hand:after{content:'';width:7px;height:7px;border-radius:50%;background-color:#00bfff;position:absolute;bottom:-3px;left:-3.5px}.clock-face__clock-hand_minute:before{content:'';width:7px;height:7px;background-color:#fff;border:4px solid #00bfff;border-radius:50%;position:absolute;top:-8px;left:calc(50% - 8px);-webkit-box-sizing:content-box;box-sizing:content-box}@media (max-width:1023px) and (orientation:landscape){.clock-face{width:225px;height:225px;padding:5px}.clock-face__number--outer{height:calc(225px / 2 - 5px)}.clock-face__clock-hand_minute:before{top:0}}"]
            },] },
];
NgxMaterialTimepickerFaceComponent.ctorParameters = function () { return []; };
NgxMaterialTimepickerFaceComponent.propDecorators = {
    "faceTime": [{ type: core.Input },],
    "selectedTime": [{ type: core.Input },],
    "unit": [{ type: core.Input },],
    "format": [{ type: core.Input },],
    "timeChange": [{ type: core.Output },],
    "clockFace": [{ type: core.ViewChild, args: ['clockFace',] },],
    "clockHand": [{ type: core.ViewChild, args: ['clockHand',] },],
    "onMousedown": [{ type: core.HostListener, args: ['touchstart', ['$event'],] }, { type: core.HostListener, args: ['mousedown', ['$event'],] },],
    "selectTime": [{ type: core.HostListener, args: ['click', ['$event'],] }, { type: core.HostListener, args: ['touchmove', ['$event.changedTouches[0]'],] }, { type: core.HostListener, args: ['touchend', ['$event.changedTouches[0]'],] }, { type: core.HostListener, args: ['mousemove', ['$event'],] },],
    "onMouseup": [{ type: core.HostListener, args: ['touchend', ['$event'],] }, { type: core.HostListener, args: ['mouseup', ['$event'],] },],
};
function roundAngle(angle, step) {
    var roundedAngle = Math.round(angle / step) * step;
    return roundedAngle === 0 ? 360 : roundedAngle;
}
function countAngleByCords(x0, y0, x, y, currentAngle) {
    if (y > y0 && x >= x0) {
        return 180 - currentAngle;
    }
    else if (y > y0 && x < x0) {
        return 180 + currentAngle;
    }
    else if (y < y0 && x < x0) {
        return 360 - currentAngle;
    }
    else {
        return currentAngle;
    }
}
var TimeFormatterPipe = /** @class */ (function () {
    function TimeFormatterPipe() {
    }
    TimeFormatterPipe.prototype.transform = function (time, timeUnit) {
        if (!time) {
            return time;
        }
        switch (timeUnit) {
            case TimeUnit.HOUR:
                return _moment.utc(time * 3600 * 1000).format('HH');
            case TimeUnit.MINUTE:
                return _moment.utc(time * 60 * 1000).format('mm');
        }
    };
    return TimeFormatterPipe;
}());
TimeFormatterPipe.decorators = [
    { type: core.Pipe, args: [{
                name: 'timeFormatter'
            },] },
];
TimeFormatterPipe.ctorParameters = function () { return []; };
var NgxMaterialTimepickerButtonComponent = /** @class */ (function () {
    function NgxMaterialTimepickerButtonComponent() {
    }
    return NgxMaterialTimepickerButtonComponent;
}());
NgxMaterialTimepickerButtonComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-material-timepicker-button',
                template: "<button class=\"timepicker-button\" type=\"button\">\n  <span><ng-content></ng-content></span>\n</button>\n",
                styles: ["@import url(https://fonts.googleapis.com/css?family=Roboto:400,500,700);.timepicker-button{display:inline-block;height:36px;min-width:88px;line-height:36px;border:12px;border-radius:2px;background-color:transparent;color:#00bfff;text-align:center;-webkit-transition:all 450ms cubic-bezier(.23,1,.32,1);transition:all 450ms cubic-bezier(.23,1,.32,1);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;cursor:pointer;outline:0}.timepicker-button:focus,.timepicker-button:hover{background-color:rgba(153,153,153,.2)}.timepicker-button>span{font-size:14px;text-transform:uppercase;font-weight:600;padding-left:16px;padding-right:16px;font-family:Roboto,sans-serif}"]
            },] },
];
NgxMaterialTimepickerButtonComponent.ctorParameters = function () { return []; };
var VALUE_ACCESSOR = {
    provide: forms.NG_VALUE_ACCESSOR,
    useExisting: core.forwardRef(function () { return TimepickerDirective; }),
    multi: true
};
var TimepickerDirective = /** @class */ (function () {
    function TimepickerDirective(elementRef) {
        this.elementRef = elementRef;
        this.onTouched = function () {
        };
        this.timepickerSubscriptions = [];
        this.onChange = function () {
        };
    }
    Object.defineProperty(TimepickerDirective.prototype, "timepicker", {
        set: function (picker) {
            this.registerTimepicker(picker);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "format", {
        get: function () {
            return this._format;
        },
        set: function (value) {
            this._format = value === 24 ? 24 : 12;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "min", {
        get: function () {
            return this._min;
        },
        set: function (value) {
            if (typeof value === 'string') {
                this._min = TimeAdapter.convertTimeToMoment(value);
                return;
            }
            this._min = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "max", {
        get: function () {
            return this._max;
        },
        set: function (value) {
            if (typeof value === 'string') {
                this._max = TimeAdapter.convertTimeToMoment(value);
                return;
            }
            this._max = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (value) {
            if (!value) {
                return;
            }
            this._value = TimeAdapter.formatTime(value, this._format);
            if (this.isValueAvailableToUpdate()) {
                this.updateInputValue();
                return;
            }
            console.warn('Selected time doesn\'t match min or max value');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "defaultTime", {
        set: function (time) {
            if (this.isValueAvailableToUpdate()) {
                this._timepicker.setDefaultTime(TimeAdapter.formatTime(time, this._format));
            }
        },
        enumerable: true,
        configurable: true
    });
    TimepickerDirective.prototype.onInput = function (value) {
        this._value = value;
        this.onChange(value);
    };
    TimepickerDirective.prototype.ngOnChanges = function (changes) {
        if (changes['value'] && changes['value'].currentValue) {
            this.defaultTime = changes['value'].currentValue;
        }
    };
    TimepickerDirective.prototype.onClick = function (event) {
        if (!this.disableClick) {
            this._timepicker.open();
            event.stopPropagation();
        }
    };
    TimepickerDirective.prototype.writeValue = function (value) {
        this.value = value;
        this.defaultTime = value;
    };
    TimepickerDirective.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    TimepickerDirective.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    TimepickerDirective.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    TimepickerDirective.prototype.ngOnDestroy = function () {
        this.timepickerSubscriptions.forEach(function (s) { return s.unsubscribe(); });
    };
    TimepickerDirective.prototype.registerTimepicker = function (picker) {
        var _this = this;
        if (picker) {
            this._timepicker = picker;
            this._timepicker.registerInput(this);
            this.timepickerSubscriptions.push(this._timepicker.timeSet.subscribe(function (time) {
                _this.value = time;
                _this.onChange(_this._value);
                _this.onTouched();
            }));
            this.timepickerSubscriptions.push(this._timepicker.closed.subscribe(function () { return _this.defaultTime = _this._value; }));
        }
    };
    TimepickerDirective.prototype.updateInputValue = function () {
        this.elementRef.nativeElement.value = this._value;
    };
    TimepickerDirective.prototype.isValueAvailableToUpdate = function () {
        var isAfter = this._min && TimeAdapter.convertTimeToMoment(this._value).isAfter(this._min);
        var isBefore = this._max && TimeAdapter.convertTimeToMoment(this._value).isBefore(this._max);
        var isBetween = (this._min && this._max)
            && TimeAdapter.convertTimeToMoment(this._value).isBetween(this._min, this._max, 'minutes');
        var isAvailable = !this._min && !this._max;
        return isAfter || isBefore || isBetween || isAvailable;
    };
    return TimepickerDirective;
}());
TimepickerDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[ngxTimepicker]',
                providers: [VALUE_ACCESSOR],
                host: {
                    '[disabled]': 'disabled',
                    '(input)': 'onInput($event.target.value)',
                    '(blur)': 'onTouched()',
                },
            },] },
];
TimepickerDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
]; };
TimepickerDirective.propDecorators = {
    "disabled": [{ type: core.Input },],
    "disableClick": [{ type: core.Input },],
    "timepicker": [{ type: core.Input, args: ['ngxTimepicker',] },],
    "format": [{ type: core.Input },],
    "min": [{ type: core.Input },],
    "max": [{ type: core.Input },],
    "value": [{ type: core.Input },],
    "onClick": [{ type: core.HostListener, args: ['click', ['$event'],] },],
};
var OverlayDirective = /** @class */ (function () {
    function OverlayDirective(eventService) {
        this.eventService = eventService;
    }
    OverlayDirective.prototype.onClick = function (e) {
        this.eventService.backdropClickSubject.next(e);
        e.preventDefault();
    };
    return OverlayDirective;
}());
OverlayDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[overlay]'
            },] },
];
OverlayDirective.ctorParameters = function () { return [
    { type: NgxMaterialTimepickerEventService, },
]; };
OverlayDirective.propDecorators = {
    "onClick": [{ type: core.HostListener, args: ['click', ['$event'],] },],
};
var FocusAnchorDirective = /** @class */ (function () {
    function FocusAnchorDirective(document, elementRef) {
        this.document = document;
        this.element = elementRef.nativeElement;
    }
    FocusAnchorDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.activeElement = (this.document.activeElement);
        setTimeout(function () { return _this.element.focus(); });
    };
    FocusAnchorDirective.prototype.ngOnDestroy = function () {
        var _this = this;
        setTimeout(function () { return _this.activeElement.focus(); });
    };
    return FocusAnchorDirective;
}());
FocusAnchorDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[focusAnchor]'
            },] },
];
FocusAnchorDirective.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] },] },
    { type: core.ElementRef, },
]; };
var NgxMaterialTimepickerToggleIconDirective = /** @class */ (function () {
    function NgxMaterialTimepickerToggleIconDirective() {
    }
    return NgxMaterialTimepickerToggleIconDirective;
}());
NgxMaterialTimepickerToggleIconDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ngxMaterialTimepickerToggleIcon]' },] },
];
NgxMaterialTimepickerToggleIconDirective.ctorParameters = function () { return []; };
var NgxMaterialTimepickerToggleComponent = /** @class */ (function () {
    function NgxMaterialTimepickerToggleComponent() {
    }
    Object.defineProperty(NgxMaterialTimepickerToggleComponent.prototype, "disabled", {
        get: function () {
            return this._disabled === undefined ? this.timepicker.disabled : this._disabled;
        },
        set: function (value) {
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    NgxMaterialTimepickerToggleComponent.prototype.open = function (event) {
        if (this.timepicker) {
            this.timepicker.open();
            event.stopPropagation();
        }
    };
    return NgxMaterialTimepickerToggleComponent;
}());
NgxMaterialTimepickerToggleComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-material-timepicker-toggle',
                template: "<button class=\"ngx-material-timepicker-toggle\" (click)=\"open($event)\" [disabled]=\"disabled\" type=\"button\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\" *ngIf=\"!customIcon\">\n        <path\n            d=\"M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z\"/>\n    </svg>\n    <ng-content select=\"[ngxMaterialTimepickerToggleIcon]\"></ng-content>\n</button>\n",
                styles: [".ngx-material-timepicker-toggle{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:4px;background-color:transparent;border-radius:50%;text-align:center;border:none;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-transition:background-color .3s;transition:background-color .3s;cursor:pointer}.ngx-material-timepicker-toggle:focus{background-color:rgba(0,0,0,.07)}"]
            },] },
];
NgxMaterialTimepickerToggleComponent.ctorParameters = function () { return []; };
NgxMaterialTimepickerToggleComponent.propDecorators = {
    "timepicker": [{ type: core.Input, args: ['for',] },],
    "disabled": [{ type: core.Input },],
    "customIcon": [{ type: core.ContentChild, args: [NgxMaterialTimepickerToggleIconDirective,] },],
};
var NgxMaterialTimepickerHoursFaceComponent = /** @class */ (function () {
    function NgxMaterialTimepickerHoursFaceComponent(hours) {
        this.hourChange = new core.EventEmitter();
        this.hourSelected = new core.EventEmitter();
        this.hoursList = [];
        this.initHours(hours);
    }
    NgxMaterialTimepickerHoursFaceComponent.prototype.onClick = function () {
        this.hourSelected.next();
    };
    NgxMaterialTimepickerHoursFaceComponent.prototype.initHours = function (hours) {
        var angleStep = 30;
        this.hoursList = Array(hours).fill(1).map(function (v, i) {
            var time = v + i;
            return { time: time === 24 ? '00' : time, angle: angleStep * time };
        });
    };
    return NgxMaterialTimepickerHoursFaceComponent;
}());
NgxMaterialTimepickerHoursFaceComponent.propDecorators = {
    "selectedHour": [{ type: core.Input },],
    "minTime": [{ type: core.Input },],
    "maxTime": [{ type: core.Input },],
    "hourChange": [{ type: core.Output },],
    "hourSelected": [{ type: core.Output },],
    "onClick": [{ type: core.HostListener, args: ['touchend',] }, { type: core.HostListener, args: ['click',] },],
};
var moment$3 = _moment;
var NgxMaterialTimepicker12HoursFaceComponent = /** @class */ (function (_super) {
    __extends(NgxMaterialTimepicker12HoursFaceComponent, _super);
    function NgxMaterialTimepicker12HoursFaceComponent() {
        return _super.call(this, 12) || this;
    }
    Object.defineProperty(NgxMaterialTimepicker12HoursFaceComponent.prototype, "disabledHours", {
        get: function () {
            var _this = this;
            if (this.minTime || this.maxTime) {
                return this.hoursList.map(function (value) {
                    var currentHour = _this.period === TimePeriod.AM ? +value.time : +value.time + 12;
                    var hour = _this.period === TimePeriod.AM && currentHour === 12 ? 0 : currentHour;
                    var currentTime = moment$3().hour(hour);
                    return Object.assign({}, value, { disabled: currentTime.isBefore(_this.minTime || null, 'hours')
                            || currentTime.isAfter(_this.maxTime || null, 'hours') });
                });
            }
            return this.hoursList;
        },
        enumerable: true,
        configurable: true
    });
    NgxMaterialTimepicker12HoursFaceComponent.prototype.ngOnChanges = function (changes) {
        if (changes['period'] && changes['period'].currentValue) {
            this.hoursList = this.disabledHours;
        }
    };
    return NgxMaterialTimepicker12HoursFaceComponent;
}(NgxMaterialTimepickerHoursFaceComponent));
NgxMaterialTimepicker12HoursFaceComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-material-timepicker-12-hours-face',
                template: "<ngx-material-timepicker-face [selectedTime]=\"selectedHour\" [faceTime]=\"hoursList\"\n                              (timeChange)=\"hourChange.next($event)\"></ngx-material-timepicker-face>\n"
            },] },
];
NgxMaterialTimepicker12HoursFaceComponent.ctorParameters = function () { return []; };
NgxMaterialTimepicker12HoursFaceComponent.propDecorators = {
    "period": [{ type: core.Input },],
};
var moment$4 = _moment;
var NgxMaterialTimepicker24HoursFaceComponent = /** @class */ (function (_super) {
    __extends(NgxMaterialTimepicker24HoursFaceComponent, _super);
    function NgxMaterialTimepicker24HoursFaceComponent() {
        return _super.call(this, 24) || this;
    }
    Object.defineProperty(NgxMaterialTimepicker24HoursFaceComponent.prototype, "disabledHours", {
        get: function () {
            var _this = this;
            if (this.minTime || this.maxTime) {
                return this.hoursList.map(function (value) {
                    var currentTime = moment$4().hour(+value.time);
                    return Object.assign({}, value, { disabled: currentTime.isBefore(_this.minTime || null, 'hours')
                            || currentTime.isAfter(_this.maxTime || null, 'hours') });
                });
            }
            return this.hoursList;
        },
        enumerable: true,
        configurable: true
    });
    NgxMaterialTimepicker24HoursFaceComponent.prototype.ngAfterContentInit = function () {
        this.hoursList = this.disabledHours;
    };
    return NgxMaterialTimepicker24HoursFaceComponent;
}(NgxMaterialTimepickerHoursFaceComponent));
NgxMaterialTimepicker24HoursFaceComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-material-timepicker-24-hours-face',
                template: "<ngx-material-timepicker-face [selectedTime]=\"selectedHour\" [faceTime]=\"hoursList\" [format]=\"format\"\n                              (timeChange)=\"hourChange.next($event)\"></ngx-material-timepicker-face>\n"
            },] },
];
NgxMaterialTimepicker24HoursFaceComponent.ctorParameters = function () { return []; };
NgxMaterialTimepicker24HoursFaceComponent.propDecorators = {
    "format": [{ type: core.Input },],
};
var NgxMaterialTimepickerModule = /** @class */ (function () {
    function NgxMaterialTimepickerModule() {
    }
    NgxMaterialTimepickerModule.forRoot = function () {
        return {
            ngModule: NgxMaterialTimepickerModule,
            providers: [NgxMaterialTimepickerService, NgxMaterialTimepickerEventService]
        };
    };
    return NgxMaterialTimepickerModule;
}());
NgxMaterialTimepickerModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule
                ],
                exports: [
                    NgxMaterialTimepickerComponent,
                    NgxMaterialTimepickerToggleComponent,
                    TimepickerDirective,
                    NgxMaterialTimepickerToggleIconDirective
                ],
                declarations: [
                    NgxMaterialTimepickerComponent,
                    NgxMaterialTimepicker24HoursFaceComponent,
                    NgxMaterialTimepicker12HoursFaceComponent,
                    NgxMaterialTimepickerMinutesFaceComponent,
                    NgxMaterialTimepickerFaceComponent,
                    NgxMaterialTimepickerToggleComponent,
                    StyleSanitizerPipe,
                    TimeFormatterPipe,
                    NgxMaterialTimepickerButtonComponent,
                    TimepickerDirective,
                    OverlayDirective,
                    FocusAnchorDirective,
                    NgxMaterialTimepickerToggleIconDirective
                ]
            },] },
];
NgxMaterialTimepickerModule.ctorParameters = function () { return []; };

exports.NgxMaterialTimepickerModule = NgxMaterialTimepickerModule;
exports.j = NgxMaterialTimepicker12HoursFaceComponent;
exports.h = NgxMaterialTimepicker24HoursFaceComponent;
exports.o = NgxMaterialTimepickerButtonComponent;
exports.l = NgxMaterialTimepickerFaceComponent;
exports.i = NgxMaterialTimepickerHoursFaceComponent;
exports.k = NgxMaterialTimepickerMinutesFaceComponent;
exports.e = NgxMaterialTimepickerToggleComponent;
exports.q = FocusAnchorDirective;
exports.f = NgxMaterialTimepickerToggleIconDirective;
exports.g = TimepickerDirective;
exports.p = OverlayDirective;
exports.a = AnimationState;
exports.b = NgxMaterialTimepickerComponent;
exports.m = StyleSanitizerPipe;
exports.n = TimeFormatterPipe;
exports.d = NgxMaterialTimepickerEventService;
exports.c = NgxMaterialTimepickerService;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-material-timepicker.umd.js.map
